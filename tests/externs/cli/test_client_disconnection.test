#!/usr/bin/env bash

#
#  All rights reserved (c) 2014-2025 CEA/DAM.
#
#  This file is part of Phobos.
#
#  Phobos is free software: you can redistribute it and/or modify it under
#  the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation, either version 2.1 of the Licence, or
#  (at your option) any later version.
#
#  Phobos is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with Phobos. If not, see <http://www.gnu.org/licenses/>.
#

#
# Test that the phobosd does not get stuck when a client disconnects without
# releasing its resources.
#

test_dir=$(dirname $(readlink -e $0))
. $test_dir/test_env.sh
. $test_dir/setup_db.sh
. $test_dir/test_launch_daemon.sh
. $test_dir/tape_drive.sh
. $test_dir/utils_generation.sh
. $test_dir/utils.sh

function dir_setup
{
    setup_tables
    # start phobosd manually to kill it even if client1 never releases the lock
    DAEMON_PID_FILEPATH=$test_bin_dir/phobosd.pid \
        $LOG_COMPILER $LOG_FLAGS $phobosd &
    wait $!
    phobosd_pid=$(cat "$test_bin_dir/phobosd.pid")

    local dir="$(mktemp -d "$DIR_TEST_IN/test.pho.XXXX")"
    echo "adding directory $dir"
    $phobos dir add $dir
    $phobos dir format --fs posix --unlock $dir
    export PHOBOS_STORE_default_family="dir"
}

function tape_setup
{
    setup_tables
    invoke_tlc
    # start phobosd manually to kill it even if client1 never releases the lock
    DAEMON_PID_FILEPATH=$test_bin_dir/phobosd.pid \
        $LOG_COMPILER $LOG_FLAGS $phobosd &
    wait $!
    phobosd_pid=$(cat "$test_bin_dir/phobosd.pid")

    # get tape
    local tape="$(get_tapes L6 1)"
    $phobos tape add --type lto6 "$tape"

    # get drive
    local drive="$(get_lto_drives 6 1)"
    $phobos drive add --unlock $drive

    # format tape
    $phobos tape format $tape --unlock
    export PHOBOS_STORE_default_family="tape"
}

function env_setup
{
    export PHOBOS_LRS_lock_file="$test_dir/phobosd.lock"

    setup_test_dirs
    setup_dummy_files 1 1k 1
    out_file="$DIR_TEST_OUT/out_file"
}

function env_cleanup
{
    rm -f ${PHOBOS_LRS_lock_file}
    rm -f "$test_bin_dir/phobosd.pid"
    unset PHOBOS_LRS_lock_file
    unset PHOBOS_STORE_default_family
    if [[ -w /dev/changer ]]; then
        waive_tlc
    fi

    drop_tables
    if [[ -w /dev/changer ]]; then
        drain_all_drives
    fi

    cleanup_dummy_files
    cleanup_test_dirs
}

function dir_cleanup
{
    kill -9 ${phobosd_pid}
    rm -f ${PHOBOS_LRS_lock_file}
    rm -f "$test_bin_dir/phobosd.pid"
    drop_tables
}

function tape_cleanup
{
    kill -9 ${phobosd_pid}
    rm -f ${PHOBOS_LRS_lock_file}
    rm -f "$test_bin_dir/phobosd.pid"
    waive_tlc
    drop_tables
    drain_all_drives
}

# Execute a put command but quit without ending after having get the booking
function writer_quit_after_recv_alloc
{
    (
        tmp_gdb_script=$(mktemp)
        trap "rm $tmp_gdb_script" EXIT
        cat <<EOF > "$tmp_gdb_script"
set breakpoint pending on
break raid_writer_split_setup
commands
quit
end
run $phobos $*
EOF

        DEBUGINFOD_URLS="" gdb -batch -x "$tmp_gdb_script" -q python3
    )
}

# Execute a get command but quit without ending after having get the booking
function reader_quit_after_recv_alloc
{
    (
        tmp_gdb_script=$(mktemp)
        trap "rm $tmp_gdb_script" EXIT
        cat <<EOF > "$tmp_gdb_script"
set breakpoint pending on
break raid_reader_split_setup
commands
quit
end
run $phobos $*
EOF

        DEBUGINFOD_URLS="" gdb -batch -x "$tmp_gdb_script" -q python3
    )
}

function test_client_disconnection_after_recv_alloc
{
    writer_quit_after_recv_alloc put --layout raid1 --lyt-params repl_count=1 ${FILES[0]} oid1 &
    local pid1=$!
    wait $pid1
    $phobos put --layout raid1 --lyt-params repl_count=1 ${FILES[0]} oid2 ||
        error "Object oid2 should be put even if first client failed"

    oids="$($phobos extent list -o oid)"
    if [[ "${oids}" !=  "oid2" ]]; then
        error "oid2 should be the existing one"
    fi

    reader_quit_after_recv_alloc get oid2 $out_file
    local pid1=$!
    wait $pid1
    rm -rf $out_file
    $phobos get oid2 $out_file ||
        error "We must successfully get oid2 after first get crash."
    diff $out_file ${FILES[0]} ||
        error "We must successfully get the content of oid2."
    rm -rf $out_file
}

# Execute a phobos command but quit without ending after sending alloc request
function phobos_quit_after_sending_alloc
{
    (
        tmp_gdb_script=$(mktemp)
        trap "rm $tmp_gdb_script" EXIT
        cat <<EOF > "$tmp_gdb_script"
set breakpoint pending on
break store_dispatch_loop
commands
quit
end
run $phobos $*
EOF

        DEBUGINFOD_URLS="" gdb -batch -x "$tmp_gdb_script" -q python3
    )
}

function test_client_disconnection_after_sending_alloc
{
    phobos_quit_after_sending_alloc put --layout raid1 --lyt-params repl_count=1 ${FILES[0]} oid1 &
    local pid1=$!
    wait $pid1
    $phobos put --layout raid1 --lyt-params repl_count=1 ${FILES[0]} oid2 ||
        error "Object oid2 should be put even if first client failed"

    oids="$($phobos extent list -o oid)"
    if [[ "${oids}" !=  "oid2" ]]; then
        error "oid2 should be the existing one"
    fi

    phobos_quit_after_sending_alloc get oid2 $out_file
    local pid1=$!
    wait $pid1
    rm -rf $out_file
    $phobos get oid2 $out_file ||
        error "We must successfully get oid2 after first get crash."
    diff $out_file ${FILES[0]} ||
        error "We must successfully get the content of oid2."
    rm -rf $out_file
}

TEST_SETUP=env_setup
TEST_CLEANUP=env_cleanup

TESTS=("dir_setup; test_client_disconnection_after_recv_alloc; dir_cleanup")
TESTS+=("dir_setup; test_client_disconnection_after_sending_alloc; dir_cleanup")


if [[ -w /dev/changer ]]; then
    TESTS+=("tape_setup; test_client_disconnection_after_recv_alloc; tape_cleanup")
    TESTS+=("tape_setup; test_client_disconnection_after_sending_alloc; tape_cleanup")
fi
